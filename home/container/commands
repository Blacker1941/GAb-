import { SlashCommandBuilder, AttachmentBuilder } from 'discord.js';
import fs from 'fs';
import Canvas from 'canvas';


// export Ø³ÛŒÙ†Ú©Ø±ÙˆÙ† Ø¨Ø±Ø§ÛŒ deploy-commands
export const data = new SlashCommandBuilder()
  .setName('forexmarket')
  .setDescription('ğŸ“ˆ Ù†Ù…Ø§ÛŒØ´ Ú†Ø§Ø±Øª Ú©Ù†Ø¯Ù„ÛŒ ÛŒÚ© Ø¢ÛŒØªÙ… Ø§Ø² Ø¨Ø§Ø²Ø§Ø± ÙØ§Ø±Ú©Ø³')
  .addStringOption(option =>
    option
      .setName('item')
      .setDescription('Ø¢ÛŒØªÙ… Ù…ÙˆØ±Ø¯ Ù†Ø¸Ø± (Ù…Ø«Ù„Ø§Ù‹ gold ÛŒØ§ oil ÛŒØ§ Ù¾ÙˆÙ„ Ù…Ù„ÛŒ Ú©Ø´ÙˆØ±)')
      .setRequired(true)
  );

// ØªØ§Ø¨Ø¹ async Ø§Ø¬Ø±Ø§ÛŒ Ú©Ø§Ù…Ù†Ø¯ (Ù‡Ù…ÙˆÙ† Ú©Ø¯ÛŒ Ú©Ù‡ Ø¯Ø§Ø±ÛŒ)
export async function execute(interaction) {
  const item = interaction.options.getString('item');
  await interaction.deferReply();

  try {
    const [marketRaw, economyRaw] = await Promise.all([
      fs.promises.readFile('market.json', 'utf8'),
      fs.promises.readFile('economy.json', 'utf8')
    ]);
    const market = JSON.parse(marketRaw);
    const users = JSON.parse(economyRaw);

    if (!market[item] || !Array.isArray(market[item].history)) {
      return await interaction.editReply({ content: 'âŒ Ø¢ÛŒØªÙ… Ù…ÙˆØ±Ø¯ Ù†Ø¸Ø± Ø¯Ø± Ø¨Ø§Ø²Ø§Ø± ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ø¯ ÛŒØ§ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ Ù†Ø§Ù…Ø¹ØªØ¨Ø±Ù†Ø¯.' });
    }

    const candles = market[item].history.slice(-24);
    const width = 700;
    const height = 340;

    const canvas = Canvas.createCanvas(width, height);
    const ctx = canvas.getContext('2d');

    // Ù¾Ø³â€ŒØ²Ù…ÛŒÙ†Ù‡
    ctx.fillStyle = '#111';
    ctx.fillRect(0, 0, width, height);

    // Ø¹Ù†ÙˆØ§Ù†
    ctx.fillStyle = '#FFD700';
    ctx.font = '20px sans-serif';
    ctx.fillText(`ğŸ“Š ${item.toUpperCase()} Market - Candlestick Chart`, 20, 30);

    // ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ú†Ø§Ø±Øª
    const chartX = 50;
    const chartY = 50;
    const chartWidth = width - 100;
    const chartHeight = height - 100;

    // Ù…Ø­ÙˆØ±
    ctx.strokeStyle = '#444';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(chartX, chartY);
    ctx.lineTo(chartX, chartY + chartHeight);
    ctx.lineTo(chartX + chartWidth, chartY + chartHeight);
    ctx.stroke();

    // Ù…Ù‚ÛŒØ§Ø³â€ŒÙ‡Ø§
    const highs = candles.map(c => c.high);
    const lows = candles.map(c => c.low);
    const max = Math.max(...highs);
    const min = Math.min(...lows);
    const yScale = chartHeight / (max - min || 1);
    const xStep = chartWidth / candles.length;

    // Ù†Ù…Ø§ÛŒØ´ Ù‚ÛŒÙ…Øª ÙØ¹Ù„ÛŒ
    const currentPrice = candles[candles.length - 1].close;
    const currentY = chartY + chartHeight - (currentPrice - min) * yScale;
    ctx.setLineDash([5, 5]);
    ctx.strokeStyle = '#8888FF';
    ctx.beginPath();
    ctx.moveTo(chartX, currentY);
    ctx.lineTo(chartX + chartWidth, currentY);
    ctx.stroke();
    ctx.setLineDash([]);

    // Ø¨Ø±Ú†Ø³Ø¨ Ù‚ÛŒÙ…Øª ÙØ¹Ù„ÛŒ
    ctx.fillStyle = '#8888FF';
    ctx.font = '19px sans-serif';
    ctx.fillText(`$${currentPrice}`, chartX + chartWidth + 5, currentY + 5);

    // Ù†Ù…Ø§ÛŒØ´ Ø¨Ø±Ú†Ø³Ø¨ Ù‚ÛŒÙ…Øªâ€ŒÙ‡Ø§ Ø¯Ø± Ø³Ù…Øª Ø±Ø§Ø³Øª
    ctx.fillStyle = '#666';
    ctx.font = '12px sans-serif';

    const priceSteps = 6;
    for (let i = 0; i <= priceSteps; i++) {
      const p = min + ((max - min) / priceSteps) * i;
      const y = chartY + chartHeight - (p - min) * yScale;
      ctx.beginPath();
      ctx.moveTo(chartX - 4, y);
      ctx.lineTo(chartX, y);
      ctx.stroke();
      ctx.fillText(`$${Math.round(p)}`, chartX + chartWidth + 5, y + 4);
    }

    // Ø±Ø³Ù… Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§ Ùˆ Ø³Ø§Ø¹Øªâ€ŒÙ‡Ø§
    candles.forEach((candle, i) => {
      const x = chartX + i * xStep + xStep / 4;
      const candleWidth = xStep / 2;

      const openY = chartY + chartHeight - (candle.open - min) * yScale;
      const closeY = chartY + chartHeight - (candle.close - min) * yScale;
      const highY = chartY + chartHeight - (candle.high - min) * yScale;
      const lowY = chartY + chartHeight - (candle.low - min) * yScale;

      const isBull = candle.close >= candle.open;
      ctx.fillStyle = isBull ? '#00ff88' : '#ff4444';
      ctx.strokeStyle = ctx.fillStyle;

      const bodyY = isBull ? closeY : openY;
      const bodyHeight = Math.max(Math.abs(openY - closeY), 1);
      ctx.fillRect(x, bodyY, candleWidth, bodyHeight);

      ctx.beginPath();
      ctx.moveTo(x + candleWidth / 2, highY);
      ctx.lineTo(x + candleWidth / 2, lowY);
      ctx.stroke();

      ctx.fillStyle = '#888';
      ctx.font = '10px sans-serif';
      ctx.fillText(`${i + 1}h`, x, chartY + chartHeight + 15);
    });

    // Ø®Ø· Ø®Ø±ÛŒØ¯ Ú©Ø§Ø±Ø¨Ø± (Ø§Ø®ØªÛŒØ§Ø±ÛŒ)
    const marketItemsWithBuyLine = Object.keys(market); // Ù‡Ù…Ù‡ Ø¢ÛŒØªÙ…â€ŒÙ‡Ø§
    const userId = interaction.user.id;
    const user = users[userId];
    if (user && user.forexBuyInfo && user.forexBuyInfo[item] && marketItemsWithBuyLine.includes(item)) {
      const buyInfo = user.forexBuyInfo[item];
      const avgBuyPrice = buyInfo.totalSpent / buyInfo.totalAmount;

      if (avgBuyPrice >= min && avgBuyPrice <= max) {
        const buyY = chartY + chartHeight - (avgBuyPrice - min) * yScale;

        ctx.strokeStyle = '#AA00FF';
        ctx.lineWidth = 2;
        ctx.setLineDash([10, 5]);
        ctx.beginPath();
        ctx.moveTo(chartX, buyY);
        ctx.lineTo(chartX + chartWidth, buyY);
        ctx.stroke();
        ctx.setLineDash([]);

        ctx.fillStyle = '#AA00FF';
        ctx.font = '16px sans-serif';
        ctx.fillText(`ğŸ’œ Ø®Ø±ÛŒØ¯: $${avgBuyPrice.toFixed(2)}`, chartX + chartWidth + 5, buyY + 5);
      }
    }

    const buffer = canvas.toBuffer('image/png');
    const attachment = new AttachmentBuilder(buffer, { name: `${item}_candlestick_chart.png` });

    await interaction.editReply({
      content: `ğŸ“ˆ Ù†Ù…ÙˆØ¯Ø§Ø± Ú©Ù†Ø¯Ù„ÛŒ ${item.toUpperCase()} Ø¯Ø± Û²Û´ Ø³Ø§Ø¹Øª Ú¯Ø°Ø´ØªÙ‡:`,
      files: [attachment]
    });

  } catch (err) {
    console.error('âŒ Ø®Ø·Ø§ Ø¯Ø± Ø±Ø³Ù… Ú©Ù†Ø¯Ù„:', err);
    await interaction.editReply({ content: 'Ø®Ø·Ø§ÛŒÛŒ Ø¯Ø± Ø®ÙˆØ§Ù†Ø¯Ù† ÛŒØ§ Ø±Ø³Ù… Ú†Ø§Ø±Øª Ø¨Ø§Ø²Ø§Ø± Ø±Ø® Ø¯Ø§Ø¯.' });
  }
}
